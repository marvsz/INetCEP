package nfn.service

/**
 * Created by Johannes on 31.8.2019
 */

import akka.actor.ActorRef
import nfn.tools.Helpers

import scala.collection.mutable.ArrayBuffer

//Added for contentfetch
import ccn.packet.CCNName

import scala.language.postfixOps

//Added for CCN Command Execution:
import config.StaticConfig

class Join2() extends NFNService {
  val sacepicnEnv = StaticConfig.systemPath

  /**
   * Returns the new schema name of two joined data streams
   *
   * @param leftDataStream  the name of the first data stream
   * @param rightDataStream the name of the second data stream
   * @param joinOn          the column on which to join on
   * @return the new name of the joined schemas
   */
  def getJoinedSchemaName(leftDataStream: String, rightDataStream: String, joinOn: String) =
    "Join(".concat(leftDataStream).concat(",").concat(rightDataStream).concat("|").concat(joinOn).concat(")")

  /**
   * Joins the content of two windows by matching each event of one window to all events in the other window on the given condition.
   * The output are all events generated for all the matching event pairs.
   *
   * @param left            the left stream
   * @param leftSensorName  the name of the left stream
   * @param right           the right stream
   * @param rightSensorName the name of the right stream
   * @param joinOn          the column on which the streams are matched
   * @param conditions      a list of conditions that is applied
   * @param joinType        the type of the join. [innerJoin,leftOuterJoin,rightOuterJoin,fullOuterJoin]
   * @return the output generated by the specific join type.
   */
  def joinStreamsOn(left: String, leftSensorName: String, right: String, rightSensorName: String, joinOn: String, conditions: String, joinType: String) = {
    val joinOnPosLeft = Helpers.getColumnNumber(leftSensorName, joinOn)
    val joinOnPosRight = Helpers.getColumnNumber(rightSensorName, joinOn)
    val leftTrimmed = Helpers.trimData(left)
    val rightTrimmed = Helpers.trimData(right)
    val leftDelimiter = Helpers.getDelimiterFromLine(leftTrimmed)
    val rightDelimiter = Helpers.getDelimiterFromLine(rightTrimmed)
    val leftTrimmedSplit: Array[String] = applyConditions(leftSensorName, leftTrimmed.split("\n"), conditions, leftDelimiter)
    val rightTrimmedSplit: Array[String] = applyConditions(rightSensorName, rightTrimmed.split("\n"), conditions, rightDelimiter)
    //if the delimiters are different we need to choose one, in this case the delimiter from the left data stream
    if (leftDelimiter != rightDelimiter) {
      rightTrimmed.replace(rightDelimiter, leftDelimiter)
    }
    joinType match {
      case "innerJoinOn" => innerjoin(leftTrimmedSplit, joinOnPosLeft, rightTrimmedSplit, joinOnPosRight)
      case "leftOuterJoin" => leftOuterJoinOn(leftTrimmedSplit, joinOnPosLeft, rightTrimmedSplit, joinOnPosRight)
      case "rightOuterJoin" => rightOuterJoinOn(leftTrimmedSplit, joinOnPosLeft, rightTrimmedSplit, joinOnPosRight)
      case "fullOuterJoin" => fullOuterJoinOn(leftTrimmedSplit, joinOnPosLeft, rightTrimmedSplit, joinOnPosRight)
      case _ => "Join Type not Supported"
    }
  }

  /**
   * The output is generated only if there is a matching event in both the streams
   *
   * @param left           the left data stream
   * @param joinOnPosLeft  the tuple position in the left data stream on which to join on
   * @param right          the right data stream
   * @param joinOnPosRight the tuple position in the right data stream on which to join on
   * @return the generated output
   */
  def innerjoin(left: Array[String], joinOnPosLeft: Int, right: Array[String], joinOnPosRight: Int) = {
    val sb = new StringBuilder
    val delimiter = Helpers.getDelimiterFromLine(left(0))
    for(leftLine <- left){
      for(rightLine <- right){
        if(leftLine.split(delimiter)(joinOnPosLeft).equals(rightLine.split(delimiter)(joinOnPosRight))){
          sb.append(leftLine).append(delimiter).append(deleteJoinedOn(rightLine,joinOnPosRight,delimiter)).append("\n")
        }
      }
    }
    sb.toString()
  }

  /**
   * removes a column from a given string
   * @param line one event
   * @param joinOnPosRight the position in the event tuple to delete
   * @param delimiter the delimiter which seperates the columns
   * @return the event without the column to delete
   */
  def deleteJoinedOn(line: String, joinOnPosRight: Int, delimiter: String)={
    var newLine = line.split(delimiter).take(joinOnPosRight)
    newLine.mkString(delimiter)
  }

  /**
   * It returns all the events on the left stream even if there are no matching events on the right stream by having null values at the right stream
   *
   * @param left          the left data stream
   * @param joinOnPosLeft the tuple position in the left data stream on which to join on
   * @param right         the right data stream
   * @param joinOnPosRight
   * @return the generated output
   */
  def leftOuterJoinOn(left: Array[String], joinOnPosLeft: Int, right: Array[String], joinOnPosRight: Int) = {
    val sb = new StringBuilder
    val delimiter = Helpers.getDelimiterFromLine(left(0))
    for(leftLine <- left){
      for(rightLine <- right){
        if(leftLine.split(delimiter)(joinOnPosLeft).equals(rightLine.split(delimiter)(joinOnPosRight))){
          sb.append(leftLine).append(delimiter).append(deleteJoinedOn(rightLine,joinOnPosRight,delimiter)).append("\n")
        }
        else{
          sb.append(leftLine).append(delimiter).append(generateNullLines(rightLine,delimiter)).append("\n")
        }
      }
    }
    sb.toString()
  }

  def generateNullLines(line: String, delimiter: String): Unit ={
    val columns = line.split(delimiter).size-1
    Array.fill[String](columns)("Null").mkString(delimiter)
  }

  /**
   * It returns all the events in the right stream even if there are no matching events on the left stream by having null values at the left stream
   *
   * @param left          the left data stream
   * @param joinOnPosLeft the tuple position in the left data stream on which to join on
   * @param right         the right data stream
   * @param joinOnPosRight
   * @return the generated output
   */
  def rightOuterJoinOn(left: Array[String], joinOnPosLeft: Int, right: Array[String], joinOnPosRight: Int) = {
    val sb = new StringBuilder
    val delimiter = Helpers.getDelimiterFromLine(left(0))
    for(rightLine <- right){
      for(leftLine <- left){
        if(rightLine.split(delimiter)(joinOnPosLeft).equals(leftLine.split(delimiter)(joinOnPosRight))){
          sb.append(leftLine).append(delimiter).append(deleteJoinedOn(rightLine,joinOnPosRight,delimiter)).append("\n")
        }
        else{
          sb.append(generateNullLines(leftLine,delimiter)).append(delimiter).append(rightLine).append("\n")
        }
      }
    }
    sb.toString()
  }

  /**
   * Combines the result of the left outer join and the right outer join. Output is generated for each incoming event, even if there are no matching events in the other stream
   *
   * @param left           the left data stream
   * @param joinOnPosLeft  the tuple position in the left data stream on which to join on
   * @param right          the right data stream
   * @param joinOnPosRight the tuple position in the right data stream on which to join on
   * @return the generated output
   */
  def fullOuterJoinOn(left: Array[String], joinOnPosLeft: Int, right: Array[String], joinOnPosRight: Int) = {
    " "
  }

  def applyConditions(sensorName: String, stream: Array[String], conditions: String, delimiter: String): Array[String] = {
    val sb = new StringBuilder
    val filterArguments = parseFilterArguments(conditions)
    val aNDs = filterArguments(0)
    val oRS = filterArguments(1)
    stream.foreach(line => {
      var lineAdded = false
      var andConditionisValid = true
      aNDs.foreach(
        and =>
          if (andConditionisValid && !conditionHandler(sensorName, and, line, delimiter)) {
            andConditionisValid = false
          })
      if (andConditionisValid && !lineAdded) {
        sb.append(line.toString + "\n")
        lineAdded = true
      }
      if (!lineAdded) {
        oRS.foreach(
          or => {
            if (!lineAdded && conditionHandler(sensorName, or, line, delimiter)) {
              sb.append(line.toString + "\n")
              lineAdded = true
            }
          }
        )
      }
    }
    )
    sb.toString().split("\n")
  }

  def conditionHandler(sensor: String, filter: String, line: String, delimiter: String): Boolean = {
    val operatorPattern = "[>,<,=,<>]+".r // regex for all operators
    val operator = operatorPattern.findFirstIn(filter).toString
    val value = filter.toString.split("[>,<,=,<>]+").map(_.trim)

    var queryVariable = ""
    var queryColumn = 0

    if (operator != "")
      queryColumn = Helpers.getColumnNumber(sensor, value(0).stripPrefix("(").stripSuffix(")").trim)
    else
      return false

    queryVariable = value(1).stripPrefix("(").stripSuffix(")").trim
    matchCondition(operator, queryColumn, queryVariable, line, delimiter)
  }

  def matchCondition(operator: String, queryColumn: Int, queryVariable: String, line: String, delimiter: String): Boolean = {
    //First, split the link into schema:
    var schema = line.split(delimiter);

    var index = queryColumn - 1;

    if (schema.length > index) {
      try {
        operator match {
          case ">" => if (schema(index).toDouble > queryVariable.toString.toDouble) {
            true
          } else false
          case "<" => if (schema(index).toDouble < queryVariable.toString.toDouble) {
            true
          } else false
          case "=" => if (schema(index).toLowerCase() == queryVariable.toLowerCase()) {
            true
          } else false
          case "<>" => if (schema(index).toLowerCase() != queryVariable.toLowerCase()) {
            true
          } else false
          case "NULL" => false
          case _ => false
        }
      }
      catch {
        case e: Exception => false
      }
    }
    else {
      false
    }
  }

  def parseFilterArguments(filter: String) = {
    var retVal = new Array[ArrayBuffer[String]](2)
    var allANDs = ArrayBuffer[String]()
    var allORs = ArrayBuffer[String]()

    val orFilters = filter.split('|').map(_.trim)
    if (orFilters.length > 0 && filter.contains("|")) {
      for (oF <- orFilters) {
        //This will give us a filter that contains ||
        if (oF.contains("&")) {
          //Further splits needed:
          //Split the AND first:
          val childAndOP = oF.split("&").map(_.trim)
          for (childOP <- childAndOP) {
            //Handle each condition and put it in a list of all AND conditions
            allANDs += childOP
          }
        }
        else {
          //This part of the OR Split does not contain and ANDs. Push all to OR list:
          allORs += oF
        }
      }
    }
    else {
      //Filter doesnt contain any ORs - so filter it with ANDs
      val andFilters = filter.split("&").map(_.trim)
      if (andFilters.length > 0 && filter.contains("&")) {
        for (aF <- andFilters) {
          //This will give us a filter that contains &&
          allANDs += aF
        }
      }
      else {
        //This is a single filter (e.g. 2>1001, so add it to andFilters and pass to handler)
        allANDs += filter
      }

    }

    retVal(0) = allANDs
    retVal(1) = allORs
    retVal
  }

  override def function(interestName: CCNName, args: Seq[NFNValue], ccnApi: ActorRef): NFNValue = {
    val nodeInfo = interestName.cmps.mkString(" ")
    var nodeName = nodeInfo.substring(nodeInfo.indexOf("/node") + 6, nodeInfo.indexOf("nfn_service") - 1)

    def processJoin(inputSource: String, left: String, right: String, outputFormat: String): String = {
      LogMessage(nodeName, s"\nJoin OP Started")
      var output = ""
      if (inputSource == "name") {
        LogMessage(nodeName, "Handle left stream")
        val intermediateResultLeft = Helpers.handleNamedInputSource(nodeName, left, ccnApi)
        LogMessage(nodeName, "Handle right stream")
        val intermediateResultRight = Helpers.handleNamedInputSource(nodeName, right, ccnApi)
        output = joinStreams(intermediateResultLeft, intermediateResultRight)
      }
      else if (inputSource == "data") {
        return joinStreams(left, right)
      }
      if (outputFormat == "name") {
        output = Helpers.storeOutput(nodeName, output, "JOIN", "onOperators", ccnApi)
      }
      else {
        LogMessage(nodeName, s"Inside Join -> JOIN name: NONE, JOIN content: ${output}")
      }
      LogMessage(nodeName, s"Join OP Completed\n")
      output
    }

    def processJoinOn(inputSource: String, outputFormat: String, left: String, right: String, joinOn: String): String = {
      LogMessage(nodeName, s"\n JoinOn OP Started")
      var output = ""
      if (inputSource == "name") {
        LogMessage(nodeName, "Handle left stream")
        val intermediateResultLeft = Helpers.handleNamedInputSource(nodeName, left, ccnApi)
        LogMessage(nodeName, "Handle right stream")
        val intermediateResultRight = Helpers.handleNamedInputSource(nodeName, right, ccnApi)
        output = joinStreams(intermediateResultLeft, intermediateResultRight)
      }
      else if (inputSource == "data") {
        return joinStreams(left, right)
      }
      if (outputFormat == "name") {
        output = Helpers.storeOutput(nodeName, output, "JOIN", "onOperators", ccnApi)
      }
      else {
        LogMessage(nodeName, s"Inside Join -> JOIN name: NONE, JOIN content: ${output}")
      }
      LogMessage(nodeName, s"Join OP Completed\n")
      output
    }

    NFNStringValue(
      args match {
        case Seq(timestamp: NFNStringValue, inputSource: NFNStringValue, outputFormat: NFNStringValue, left: NFNStringValue, right: NFNStringValue) => processJoin(inputSource.str, left.str, right.str, outputFormat.str)
        case Seq(timestamp: NFNStringValue, inputSource: NFNStringValue, outputFormat: NFNStringValue, left: NFNStringValue, right: NFNStringValue, joinOn: NFNStringValue) => processJoinOn(inputSource.str, outputFormat.str, left.str, right.str, joinOn.str)
        case _ =>
          throw new NFNServiceArgumentException(s"$ccnName can only be applied to values of type NFNBinaryDataValue and not $args")
      }
    )
  }

  def joinStreams(left: String, right: String) = {
    var output = ""
    val sb = new StringBuilder
    val leftTrimmed = Helpers.trimData(left)
    val rightTrimmed = Helpers.trimData(right)
    val leftDelimiter = Helpers.getDelimiterFromLine(leftTrimmed)
    val rightDelimiter = Helpers.getDelimiterFromLine(rightTrimmed)
    val leftTrimmedSplit: Array[String] = leftTrimmed.split("\n")
    val rightTrimmedSplit: Array[String] = rightTrimmed.split("\n")
    //if the delimiters are different we need to choose one, in this case the delimiter from the left data stream
    if (leftDelimiter != rightDelimiter) {
      rightTrimmed.replace(rightDelimiter, leftDelimiter)
    }
    // We need to check whether we have equally long lines.
    val size = leftTrimmedSplit.size
    val lineDifference = leftTrimmedSplit.size - rightTrimmedSplit.size
    if (lineDifference == 0) {
      for (i <- 0 to leftTrimmedSplit.size - 1) {
        sb.append(leftTrimmedSplit(i) + leftDelimiter + rightTrimmedSplit(i) + "\n")
      }
    }
    output = sb.toString()
    if (output == "")
      output = "No Results!"
    else
      output = output.stripSuffix("\n").stripMargin('#')
    output
  }

}
